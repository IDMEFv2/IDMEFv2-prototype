{
    "description": "JSON schema for the Intrusion Detection Message Exchange Format (IDMEF) version 2 (revision 2.D.V02)",
    "properties": {
        "Version": {
            "description": "The version of the IDMEF format in use by this alert. During the drafts tuning period the version is equal to the draft version. Therefore it is \"2.D.V02\" for Draft V02.",
            "enum": [
                "2.D.V02"
            ]
        },
        "ID": {
            "description": "Unique identifier for the alert.",
            "$ref": "#/definitions/uuidType"
        },
        "Entity": {
            "description": "Tenant ID to support multi-tenancy (e.g. decentralized infrastructure, local agency, subsidiary company, etc.). Should be used when there are multiple sites/locations or multiple tenants (e.g. by Managed Security Services Providers).",
            "type": "string"
        },
        "Category": {
            "description": "The incident's category & subcategory as listed in using the format \"category.subcategory\" (e.g. \"Attempt.Exploit\").",
            "type": "array",
            "items": {
                "$ref": "#/definitions/categoryEnum"
            }
        },
        "ext-Category": {
            "description": "A means by which to extend the Category attribute. (see )",
            "type": "string"
        },
        "Cause": {
            "description": "Alert cause. The cause can be modified by any analyser on the way of the alert and later by the operator and/or the analyst if new investigation reveals and confirms a different cause of the event.",
            "$ref": "#/definitions/causeEnum"
        },
        "Description": {
            "description": "Short free text human-readable description of the event. The description can add detail to the alert classification for easiest/faster comprehension by the operator. Example : * Cryptoware WannaCry blocked on pegasus server * Unknown person entering through east doorway",
            "type": "string"
        },
        "Status": {
            "description": "Event state in the overall event lifecycle.",
            "$ref": "#/definitions/statusEnum"
        },
        "Priority": {
            "description": "Priority of the alert. Priority is defined by conbining impact and urgency. It indicates how fast the incident should be taken care of. Impact defines the enormity of the situation and mostly deals with \u201cHow Many\u201d or \u201chow much\u201d question. It can be in terms of people, finances, systems, etc. How many people and/or systems impacted, how badly are they impacted (is there potential physical impact ?) , how much financial loss, severity of legal liabilities,... Impact could be considered equivalent to \"Severity\". Urgency is associated with time. The time it takes to have the perceived Impact. For example, a high impact incident may have low urgency if the impact will not affect the business until the end of the financial year.",
            "$ref": "#/definitions/priorityEnum"
        },
        "Confidence": {
            "description": "A floating-point value between 0 and 1 indicating the analyzer's confidence in its own reliability of this particular detection, where 0 means that the detection is surely incorrect while 1 means there is no doubt about the detection made.",
            "type": "number"
        },
        "Note": {
            "description": "Free text human-readable additional note, possibly a longer description of the incident if is not already obvious. The Note attribute can be used to store any additional information. It can be additional information about the event and/or about the incident resolution, although the incident resolution information should in principle be stored elsewhere (with a link with the external tool in AltNames)",
            "type": "string"
        },
        "CreateTime": {
            "description": "Timestamp indicating when the message was created.",
            "$ref": "#/definitions/timestampType"
        },
        "StartTime": {
            "description": "Timestamp indicating the deduced start of the event. StartTime can be later than CreateTime in case or Alerts created from forecast information (e.g. Snow Storm in two days staring at 10h00)",
            "$ref": "#/definitions/timestampType"
        },
        "EndTime": {
            "description": "Timestamp indicating the deduced end of the event.",
            "$ref": "#/definitions/timestampType"
        },
        "AltNames": {
            "description": "Alternative identifiers; strings which help pair the event to internal systems' information (for example ticket IDs inside a request tracking systems).",
            "type": "array",
            "items": {
                "type": "string"
            }
        },
        "AltCategory": {
            "description": "Alternate categories from a reference other than (e.g. MISP, MITRE ATT@CK or another proprietary/internal reference).",
            "type": "array",
            "items": {
                "type": "string"
            }
        },
        "Ref": {
            "description": "References to sources of information related to the alert and/or vulnerability, and specific to this alert. This MAY be a URL to additional info, or a URN in a registered or unregistered ad-hoc namespace bearing reasonable information value and uniqueness, such as \"urn:cve:CVE-2013-2266\".",
            "type": "array",
            "items": {
                "type": "string",
                "format": "uri"
            }
        },
        "CorrelID": {
            "description": "Identifiers for the messages which were used as information sources to create this message, in case the message has been created based on correlation/analysis/deduction from other messages.",
            "type": "array",
            "items": {
                "$ref": "#/definitions/uuidType"
            }
        },
        "AggrCondition": {
            "description": "A list of IDMEF fields used to aggregate events. The values for these fields will be the same in all aggregated events. This attribute should mostly be set by intermediary nodes, which detect duplicates, or aggregate events, spanning multiple detection windows, into a longer one. The \"StartTime\" and \"EndTime\" attributes are used in conjunction with this attribute to describe the aggregation window.",
            "type": "array",
            "items": {
                "type": "string"
            }
        },
        "PredID": {
            "description": "A list containing the identifiers of previous messages which are obsoleted by this message. The obsoleted alerts SHOULD NOT be used anymore. This field can be used to \"update\" an alert.",
            "type": "array",
            "items": {
                "$ref": "#/definitions/uuidType"
            }
        },
        "RelID": {
            "description": "A list containing the identifiers of other messages related to this message.",
            "type": "array",
            "items": {
                "$ref": "#/definitions/uuidType"
            }
        },
        "Analyzer": {
            "type": "object",
            "items": {
                "description": "The Analyzer class describes the module that has analyzed the data captured by the sensors, identified an event of interest and decided to create an alert.",
                "properties": {
                    "IP": {
                        "description": "Analyzer IP address.",
                        "$ref": "#/definitions/ipType"
                    },
                    "Name": {
                        "description": "Name of the analyzer, which must be reasonably unique, however still bear some meaningful sense. This attribute usually denotes the hierarchy of organizational units the detector belongs to and its own name. It MAY also be used to distinguish multiple analyzers running with the same IP address.",
                        "type": "string"
                    },
                    "Hostname": {
                        "description": "Hostname of this analyzer. SHOULD be a fully-qualified domain name.",
                        "type": "string"
                    },
                    "Model": {
                        "description": "Analyzer model description (usually its generic name, brand and version).",
                        "type": "string"
                    },
                    "Type": {
                        "description": "Analyzer type.",
                        "type": "array",
                        "items": {
                            "$ref": "#/definitions/analyzerTypeEnum"
                        }
                    },
                    "Category": {
                        "description": "Analyzer categories.",
                        "type": "array",
                        "items": {
                            "$ref": "#/definitions/analyzerCategoryEnum"
                        }
                    },
                    "ext-Category": {
                        "description": "A means by which to extend the Category attribute. (see )",
                        "type": "string"
                    },
                    "Data": {
                        "description": "Type of data analyzed during the detection.",
                        "type": "array",
                        "items": {
                            "$ref": "#/definitions/analyzerDataEnum"
                        }
                    },
                    "ext-Data": {
                        "description": "A means by which to extend the Data attribute. (see )",
                        "type": "string"
                    },
                    "Method": {
                        "description": "Detection method.",
                        "type": "array",
                        "items": {
                            "$ref": "#/definitions/analyzerMethodEnum"
                        }
                    },
                    "ext-Method": {
                        "description": "A means by which to extend the Method attribute. (see )",
                        "type": "string"
                    },
                    "GeoLocation": {
                        "description": "GPS coordinates for the analyzer.",
                        "$ref": "#/definitions/geolocType"
                    },
                    "UnLocation": {
                        "description": "Standard UN/Locode for the analyzer.",
                        "$ref": "#/definitions/unlocodeType"
                    },
                    "Location": {
                        "description": "Internal name for the location of the analyzer.",
                        "type": "string"
                    }
                },
                "additionalProperties": false,
                "type": "object",
                "required": [
                    "IP",
                    "Name"
                ]
            }
        },
        "Sensor": {
            "type": "array",
            "items": {
                "description": "The Sensor class describes the module that captured the data before sending it to an analyzer. The Sensor may be a subpart of the Analyzer.",
                "properties": {
                    "IP": {
                        "description": "The sensor's IP address.",
                        "$ref": "#/definitions/ipType"
                    },
                    "Name": {
                        "description": "Name of the sensor, which must be reasonably unique, however still bear some meaningful sense. This attribute usually denotes the hierarchy of organizational units the sensor belongs to and its own name. It MAY also be used to distinguish multiple sensors running with the same IP address.",
                        "type": "string"
                    },
                    "Hostname": {
                        "description": "The sensor's hostname. This SHOULD be a fully qualified domain name, but may not conform exactly because values extracted from logs, messages, DNS, etc. may themselves be malformed. An empty string MAY be used to explicitly state that this value was inquired but not found (missing DNS entry).",
                        "type": "string"
                    },
                    "Model": {
                        "description": "The sensor model's description (usually its generic name, brand and version).",
                        "type": "string"
                    },
                    "GeoLocation": {
                        "description": "GPS coordinates for the analyzerr.",
                        "$ref": "#/definitions/geolocType"
                    },
                    "UnLocation": {
                        "description": "Standard UN/Locode for the sensor.",
                        "$ref": "#/definitions/unlocodeType"
                    },
                    "Location": {
                        "description": "Internal name for the location of the sensor.",
                        "type": "string"
                    },
                    "CaptureZone": {
                        "description": "A string that describes the \"capture zone\" of the sensor, as a JSON-serialized string. Depending on the type of sensor, the capture zone may for instance refer to: \n- A JSON object describing a camera's settings (elevation, horizontal and vertical field of view, azimuth, etc.)\n- A description of the IP network where packet capture is taking place.",
                        "type": "string"
                    }
                },
                "additionalProperties": false,
                "type": "object",
                "required": [
                    "IP",
                    "Name"
                ]
            }
        },
        "Source": {
            "type": "array",
            "items": {
                "description": "The Source class describes the origin(s) of the event(s) leading up to the alert.",
                "properties": {
                    "IP": {
                        "description": "Source IP address.",
                        "$ref": "#/definitions/ipType"
                    },
                    "Hostname": {
                        "description": "Hostname of this source. This SHOULD be a fully qualified domain name, but may not conform exactly because values extracted from logs, messages, DNS, etc. may themselves be malformed. An empty string MAY be used to explicitly state that this value was inquired but not found (missing DNS entry).",
                        "type": "string"
                    },
                    "Note": {
                        "description": "Free text human-readable additional note for this source.",
                        "type": "string"
                    },
                    "TI": {
                        "description": "Threat Intelligence data about the source. Values in this list MUST use the format \"attribute:origin\", where \"attribute\" refers to the attribute inside this source found inside a Threat Intelligence database, and \"origin\" contains a short identifier for the Threat Intelligence database. E.g. \"IP:Dshield\". Please note that the same attribute may appear multiple times inside the list (because a match was found in multiple Threat Intelligence databases).",
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "User": {
                        "description": "User ID or login responsible for the alert.",
                        "type": "string"
                    },
                    "Email": {
                        "description": "Email address responsible for the alert. E.g. the value of the \"Reply-To\" or \"From\" header inside a phishing e-mail.",
                        "type": "string",
                        "format": "email"
                    },
                    "Protocol": {
                        "description": "Protocols related to connections from/to this source. If several protocols are stacked, they MUST be ordered from the lowest (the closest to the medium) to the highest (the closest to the application) according to the ISO/OSI model.",
                        "type": "array",
                        "items": {
                            "$ref": "#/definitions/protocolType"
                        }
                    },
                    "Port": {
                        "description": "Source ports involved in the alert. Values in this list MUST be integers and MUST be in the range 1-65535.",
                        "type": "array",
                        "items": {
                            "type": "integer"
                        }
                    },
                    "GeoLocation": {
                        "description": "GPS coordinates for the source.",
                        "$ref": "#/definitions/geolocType"
                    },
                    "UnLocation": {
                        "description": "Standard UN/Locode for the source.",
                        "$ref": "#/definitions/unlocodeType"
                    },
                    "Location": {
                        "description": "Internal name for the location of the source.",
                        "type": "string"
                    },
                    "Attachment": {
                        "description": "Identifiers for attachments related to this source. Each identifier listed here MUST match the \"Name\" attribute for one of the attachments described using the Attachment class .",
                        "type": "array",
                        "items": {
                            "$ref": "#/definitions/attachmentNameType"
                        }
                    }
                },
                "additionalProperties": false,
                "type": "object"
            }
        },
        "Target": {
            "type": "array",
            "items": {
                "description": "The Target class describes the target(s) impacted by the event(s) leading up to the alert.",
                "properties": {
                    "IP": {
                        "description": "Target IP address.",
                        "$ref": "#/definitions/ipType"
                    },
                    "Hostname": {
                        "description": "Hostname of this target. This SHOULD be a fully qualified domain name, but may not conform exactly because values extracted from logs, messages, DNS, etc. may themselves be malformed. An empty string MAY be used to explicitly state that this value was inquired but not found (missing DNS entry).",
                        "type": "string"
                    },
                    "Note": {
                        "description": "Free text human-readable additional note for this target.",
                        "type": "string"
                    },
                    "Service": {
                        "description": "Service or process impacted by the alert.",
                        "type": "string"
                    },
                    "User": {
                        "description": "User ID or login targeted by the alert.",
                        "type": "string"
                    },
                    "Email": {
                        "description": "Email address targeted by the alert. E.g. the value of the \"To\" header inside a phishing e-mail.",
                        "type": "string",
                        "format": "email"
                    },
                    "Port": {
                        "description": "Target ports involved in the alert. Values in this list MUST be integers and MUST be in the range 1-65535.",
                        "type": "array",
                        "items": {
                            "type": "integer"
                        }
                    },
                    "GeoLocation": {
                        "description": "GPS coordinates for the target.",
                        "$ref": "#/definitions/geolocType"
                    },
                    "UnLocation": {
                        "description": "Standard UN/Locode for the target.",
                        "$ref": "#/definitions/unlocodeType"
                    },
                    "Location": {
                        "description": "Internal name for the location of the target.",
                        "type": "string"
                    },
                    "Attachment": {
                        "description": "Identifiers for attachments related to this target. Each identifier listed here MUST match the \"Name\" attribute for one of the attachments described using the Attachment class .",
                        "type": "array",
                        "items": {
                            "$ref": "#/definitions/attachmentNameType"
                        }
                    }
                },
                "additionalProperties": false,
                "type": "object"
            }
        },
        "Vector": {
            "type": "array",
            "items": {
                "description": "The Vector class describes the vector(s) of the event(s) leading up to the alert. \u2022 Name, location, description, \u2026",
                "properties": {
                    "Category": {
                        "description": "Category for the detected \"vector\".",
                        "type": "array",
                        "items": {
                            "$ref": "#/definitions/vectorCategoryEnum"
                        }
                    },
                    "ext-Category": {
                        "description": "A means by which to extend the Category attribute. (see )",
                        "type": "string"
                    },
                    "Name": {
                        "description": "Name of the detected vector or \"Unknown\". Please note that this name does not need to be unique across vectors.",
                        "type": "string"
                    },
                    "Note": {
                        "description": "Free text human-readable additional note for this vector.",
                        "type": "string"
                    },
                    "TI": {
                        "description": "Threat Intelligence data about the vector. Values in this list MUST use the format \"attribute:origin\", where \"attribute\" refers to the attribute inside this vector found inside a Threat Intelligence database, and \"origin\" contains a short identifier for the Threat Intelligence database. E.g. \"Name:FBI-Wanted\". Please note that the same attribute may appear multiple times inside the list (because a match was found in multiple Threat Intelligence databases).",
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "GeoLocation": {
                        "description": "GPS coordinates for the vector.",
                        "$ref": "#/definitions/geolocType"
                    },
                    "GeoRadius": {
                        "description": "Estimated radius around the provided geolocation in meters. This attribute can be interpreted as an error margin related to the detection of this vector.",
                        "type": "number"
                    },
                    "UnLocation": {
                        "description": "Standard UN/Locode for the vector.",
                        "$ref": "#/definitions/unlocodeType"
                    },
                    "Location": {
                        "description": "Internal name for the location of the vector.",
                        "type": "string"
                    },
                    "Attachment": {
                        "description": "Identifiers for attachments related to this vector. Each identifier listed here MUST match the \"Name\" attribute for one of the attachments described using the Attachment class .",
                        "type": "array",
                        "items": {
                            "$ref": "#/definitions/attachmentNameType"
                        }
                    }
                },
                "additionalProperties": false,
                "type": "object",
                "required": [
                    "Category"
                ]
            }
        },
        "Attachment": {
			"type": "object",
			"additionalProperties": false,
			"patternProperties": {
				"^[a-zA-Z0-9]+$": {
                    "description": "The Attachment class contains additional data which was captured in relation with the event.",
                    "properties": {
                        "FileName": {
                            "description": "Attachment filename. This will usually be the original name of the captured file or the name of the file containing the captured content (e.g. a packet capture file).",
                            "type": "string"
                        },
                        "Hash": {
                            "description": "A list of hash results for the attachment's Content. The values in this list are computed by taking the raw value of the attachment's \"Content\" attribute. The hash result is computed before any other transformation (e.g. Base64 encoding) is applied to the content, so that a receiving IDMEF system may reverse the transformation, apply the same hashing function and obtain the same hash result. See also the definition for the \"ContentEncoding\" attribute below. It is RECOMMENDED that compatible implementations use one of the hashing functions from the SHA-2 or SHA-3 families to compute the hash results in this list.",
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/hashType"
                            }
                        },
                        "Size": {
                            "description": "Length of the content (in bytes). This value MUST be a non-negative integer.",
                            "type": "integer"
                        },
                        "Ref": {
                            "description": "References to sources of information related to the alert and/or vulnerability, and specific to this attachment.",
                            "type": "array",
                            "items": {
                                "type": "string",
                                "format": "uri"
                            }
                        },
                        "ExternalURI": {
                            "description": "If the attachment's content is available and/or recognizable from an external resource, this is the URI (usually a URL) to that resource. This MAY also be a URN in a registered or unregistered ad-hoc namespace bearing reasonable information value and uniqueness, such as \"urn:mhr:55eaf7effadc07f866d1eaed9c64e7ee49fe081a\" or \"magnet:?xt=urn:sha1:YNCKHTQCWBTRNJIV4WNAE52SJUQCZO5C\".",
                            "type": "array",
                            "items": {
                                "type": "string",
                                "format": "uri"
                            }
                        },
                        "Note": {
                            "description": "Free text human-readable additional note for this attachment.",
                            "type": "string"
                        },
                        "ContentType": {
                            "description": "Internet Media Type of the attachment. For compatibility reasons, implementations SHOULD prefer one of the well-known media types registered in IANA .",
                            "$ref": "#/definitions/mediatypeType"
                        },
                        "ContentEncoding": {
                            "description": "Content encoding. The following encodings are defined in this version of the specification: \n- \"json\": The content refers to a JSON object which has been serialized to a string using the serialization procedure defined in .\n- \"base64\": The content has been serialized using the Base64 encoding defined in . The \"base64\" encoding SHOULD be used when the content contains binary data. If omitted, the \"json\" encoding MUST be assumed.",
                            "type": "string"
                        },
                        "Content": {
                            "description": "The attachment's content, in case it is directly embedded inside the message. For large attachments, it is RECOMMENDED that implementations make use of the \"ExternalURI\" attribute to refererence a copy of the content saved in an external storage mechanism.",
                            "type": ["object", "string"]
                        }
                    },
                    "additionalProperties": false,
                    "type": "object"
                }
            }
        }
    },
    "additionalProperties": false,
    "type": "object",
    "required": [
        "Analyzer",
        "Version",
        "ID",
        "CreateTime"
    ],
    "definitions": {
        "categoryEnum": {
            "enum": [
                "Abusive.Spam",
                "Abusive.Harassment",
                "Abusive.Illicit",
                "Malicious.System",
                "Malicious.Botnet",
                "Malicious.Distribution",
                "Malicious.Configuration",
                "Recon.Scanning",
                "Recon.Sniffing",
                "Recon.SocialEngineering",
                "Attempt.Exploit",
                "Attempt.Login",
                "Attempt.NewSignature",
                "Intrusion.AdminCompromise",
                "Intrusion.UserCompromise",
                "Intrusion.AppCompromise",
                "Intrusion.SysCompromise",
                "Intrusion.Burglary",
                "Availability.DoS",
                "Availability.DDoS",
                "Availability.Misconf",
                "Availability.Theft",
                "Availability.Sabotage",
                "Availability.Outage",
                "Availability.Failure",
                "Information. UnauthorizedAccess",
                "Information. UnauthorizedModification",
                "Information.DataLoss",
                "Information.DataLeak",
                "Fraud.UnauthorizedUsage",
                "Fraud.Copyright",
                "Fraud.Masquerade",
                "Fraud.Phishing",
                "Vulnerable.Crypto",
                "Vulnerable.DDoS",
                "Vulnerable.Surface",
                "Vulnerable.Disclosure",
                "Vulnerable.System",
                "Geophysical.Earthquake",
                "Geophysical.MassMovement",
                "Geophysical.Volcanic",
                "Meteorological. Temperature",
                "Meteorological.Fog",
                "Meteorological.Storm",
                "Hydrological.Flood",
                "Hydrological.Landslide",
                "Hydrological.Wave",
                "Climatological.Drought",
                "Climatological. LakeOutburst",
                "Climatological.Wildfire",
                "Biological.Epidemic",
                "Biological.Insect",
                "Biological.Animal",
                "Extraterrestrial.Impact",
                "Extraterrestrial. SpaceWeather",
                "Other.Uncategorised",
                "Other.Undetermined",
                "Test.Test",
                "ext-value"
            ],
            "description": "Possible alert category"
        },
        "causeEnum": {
            "enum": [
                "Normal",
                "Error",
                "Malicious",
                "Malfunction",
                "Hazard",
                "Unknown"
            ],
            "description": "Possible alert cause"
        },
        "statusEnum": {
            "enum": [
                "Event",
                "Incident"
            ],
            "description": "Possible alert status"
        },
        "priorityEnum": {
            "enum": [
                "Unknown",
                "Info",
                "Low",
                "Medium",
                "High"
            ],
            "description": "Possible alert priority"
        },
        "analyzerTypeEnum": {
            "enum": [
                "Cyber",
                "Physical",
                "Availability",
                "Combined"
            ],
            "description": "Possible analyzer type"
        },
        "analyzerCategoryEnum": {
            "enum": [
                "1DLiS",
                "2DLiS",
                "3DLiS",
                "1DLaS",
                "2DLaS",
                "3DLaS",
                "VAD",
                "HAR",
                "FRC",
                "VNIR",
                "SWIR",
                "MWIR",
                "LWIR",
                "ADS",
                "ODC",
                "DDOS",
                "SPAM",
                "AV",
                "EDR",
                "FW",
                "NIDS",
                "HIDS",
                "WIDS",
                "PROX",
                "WAF",
                "HPT",
                "LOG",
                "IAM",
                "VPN",
                "ETL",
                "RASP",
                "BAST",
                "NAC",
                "SIEM",
                "NMS",
                "ext-value"
            ],
            "description": "Possible analyzer category"
        },
        "analyzerDataEnum": {
            "enum": [
                "Light",
                "Noise",
                "Touch",
                "Images",
                "Vibrations",
                "Lidar",
                "Thermic",
                "Seismic",
                "Temperature",
                "Rain",
                "Water",
                "Humidity",
                "Particles",
                "Contact",
                "MagneticField",
                "Acoustics",
                "Fog",
                "External",
                "Reporting",
                "Connection",
                "Datagram",
                "Content",
                "Data",
                "File",
                "Flow",
                "Log",
                "Protocol",
                "Host",
                "Network",
                "Alert",
                "Relay",
                "Auth",
                "SNMP",
                "ext-value"
            ],
            "description": "Possible analyzer data"
        },
        "analyzerMethodEnum": {
            "enum": [
                "Biometric",
                "Policy",
                "Heat",
                "Movement",
                "Blackhole",
                "Signature",
                "Statistical",
                "Heuristic",
                "Integrity",
                "Honeypot",
                "Tarpit",
                "Recon",
                "Correlation",
                "Monitor",
                "AI",
                "Threshold",
                "ext-value"
            ],
            "description": "Possible analyzer method"
        },
        "vectorCategoryEnum": {
            "enum": [
                "Unknown",
                "Face",
                "RunningMan",
                "Human",
                "Man",
                "Woman",
                "Children",
                "Animal",
                "Object",
                "Blast",
                "Fire",
                "Wind",
                "Snow",
                "Rain",
                "Chemical",
                "Smoke",
                "Vapors",
                "Drug",
                "Device",
                "Drone",
                "Car",
                "Truck",
                "Vehicle",
                "Bird",
                "Storm",
                "HighTemperature",
                "Artifact",
                "Autonomous System",
                "Directory",
                "Domain Name",
                "Email Address",
                "Email Message",
                "File",
                "IPv4 Address",
                "IPv6 Address",
                "Mutex",
                "Network Traffic",
                "Process",
                "URL",
                "User Account",
                "Windows Registry Key",
                "X509 Certificate",
                "ext-value"
            ],
            "description": "Possible vector category"
        },
        "attachmentNameType": {
            "description": "A a unique identifier among attachments.",
            "type": "string",
            "pattern": "^[a-zA-Z0-9]+$"
        },
        "portType": {
            "description": "A network port number. The value 0 is excluded from the range because it never appears in an actual network connection.",
            "type": "integer",
            "minimum": 0,
            "maximum": 65535,
            "exclusiveMinimum": true
        },
        "timestampType": {
            "description": "A JSON string containing a timestamp conforming to the format given in section 5.6 of RFC 3339.",
            "type": "string",
            "pattern": "^[0-9]{4}-(0[0-9]|1[012])-([0-2][0-9]|3[01])T([0-1][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\\.[0-9]+)?(Z|[-+]([0-1][0-9]|2[0-3]):[0-5][0-9])?$"
        },
        "geolocType": {
            "description": "Geolocation coordinates. The format for this type matches the definition for locations inside ISO 6709 (eg. \"+48.75726, +2.299528, +65.1\").",
            "type": "string",
            "pattern": "^[-+]?([0-9]+(\\.[0-9]*)?)(, ?[-+]?([0-9]+(\\.[0-9]*)?)){1,2}$"
        },
        "unlocodeType": {
            "description": "A valid UN/LOCODE location (e.g. \"FR PAR\"). See also the UN/LOCODE Code List 2020-2 at https://unece.org/trade/cefact/unlocode-code-list-country-and-territory.",
            "type": "string",
            "pattern": "^[A-Z]{2} ?[A-Z]{3}$"
        },
        "ipType": {
            "description": "An Internet Protocol address, either version 4 or version 6.",
            "type": "string",
            "pattern": "^(((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)|([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$"
        },
        "mediatypeType": {
            "description": "A valid media type (e.g. \"text/plain\") conforming to the format defined in section 3.1.1.1 of RFC 7231. See also http://www.iana.org/assignments/media-types/media-types.xhtml.",
            "type": "string",
            "pattern": "^[-!#$%&'*+.^_`|~0-9a-zA-Z]+/[-!#$%&'*+.^_`|~0-9a-zA-Z]+([ \t]*;[ \t]*[-!#$%&'*+.^_`|~0-9a-zA-Z]+=([-!#$%&'*+.^_`|~0-9a-zA-Z]+|\"([\\x5D-~\t !#-\\x5B]|\\\\([\t 0-9a-zA-Z]))*\"))*$"
        },
        "uuidType": {
            "description": "Canonical textual representation for an UUID, as defined in RFC 4122 (e.g. \"e5f9bbae-163e-42f9-a2f2-0daaf78fefb1\")",
            "type": "string",
            "pattern": "^[0-9A-Fa-f]{8}(-[0-9A-Fa-f]{4}){3}-[0-9A-Fa-f]{12}$"
        },
        "protocolType": {
            "description": "A JSON string containing a service or protocol name from the set of permitted values defined in the IANA \"Service Name and Transport Protocol Port Number\" registry (http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml).",
            "type": "string",
            "pattern": "^[a-zA-Z0-9](-?[a-zA-Z0-9])*$"
        },
        "hashType": {
            "description": "A cryptographic hash acting as a checksum for some content, using the format \"function:hex-value\" (e.g. \"md5:dc89f0b4ff9bd3b061dd66bb66c991b1\").",
            "type": "string",
            "pattern": "^[a-zA-Z0-9-]+:([a-fA-F0-9]{2})+$"
        }
    },
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "IDMEF 2.D.V02"
}
